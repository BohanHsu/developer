package sentenceBuilder;

import grammar.ContextFreeLanguage;
import grammar.Rule;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedList;

import utility.RandomNumberGenerator;

public class IntermediateSentence {
	private LinkedList<String> sentence = null;
	private LinkedList<Rule> rules = null;
	private ContextFreeLanguage cfl = null;

	/**
	 * constructor, randomly select a start symbol from cfl
	 * 
	 * @param cfl
	 *            : a context free language
	 */
	public IntermediateSentence(ContextFreeLanguage cfl) {
		this.cfl = cfl;
		ArrayList<Rule> startSymbolRules = cfl.getMapping().get("START");
		this.rules = new LinkedList<Rule>(startSymbolRules);
		Rule selectedStartRule = randomSelectRule();
		String startSymbol = selectedStartRule.getToSymbols().get(0);
		this.sentence = new LinkedList<String>();
		sentence.add(startSymbol);
		ArrayList<Rule> allRules = this.cfl.getMapping().get(startSymbol);
		this.rules = new LinkedList<>(allRules);
	}

	/**
	 * a successor constructor take a IntermediateSentence, this argument
	 * sentence must have rule remain to check,
	 * 
	 * @param is
	 *            : a IntermediateSentence
	 */
	public IntermediateSentence(IntermediateSentence is) {
		// copy attributes from previous IS
		this.cfl = is.cfl;
		this.sentence = new LinkedList<String>(is.sentence);
		// randomly select a rule from previous IS
		Rule selectedRule = is.randomSelectRule();
		String fromSymbol = selectedRule.getFromSymbol();
		ArrayList<String> toSymbols = selectedRule.getToSymbols();
		// remove the selected rule from previous IS
		is.rules.remove(selectedRule);
		// modify sentence in this IS
		int index = this.sentence.indexOf(fromSymbol);
		this.sentence.remove(fromSymbol);
		this.sentence.addAll(index, toSymbols);
		// find first non terminal symbols in new sentence
		String firstNonTerminal = null;
		for (String symbol : this.sentence) {
			if (isNonTerminal(symbol)) {
				firstNonTerminal = symbol;
				break;
			}
		}

		if (firstNonTerminal == null) {
			// this sentence only contain Terminal Symbols
			this.rules = new LinkedList<Rule>();
		} else {
			// get rules from this symbol
			ArrayList<Rule> allRules = this.cfl.getMapping().get(
					firstNonTerminal);
			this.rules = new LinkedList<Rule>(allRules);
		}
	}

	/**
	 * given a string, determine iff this symbols is a non-terminal symbol
	 * 
	 * @param symbol
	 *            : a given symbols
	 * @return
	 */
	private boolean isNonTerminal(String symbol) {
		return this.cfl.getNonTerminalSymbols().contains(symbol);
	}

	/**
	 * randomly select a rule form this structure, according to the rule's
	 * weight
	 * 
	 * @return : a rule if possible, if no rules return null
	 */
	public Rule randomSelectRule() {
		int totalRuleWeight = 0;
		for (Rule rule : this.rules) {
			totalRuleWeight += rule.getWeight();
		}
		int randomInt = RandomNumberGenerator.randomIntTo(totalRuleWeight);
		int accmulatedWeight = 0;
		for (Rule rule : this.rules) {
			if (accmulatedWeight <= randomInt
					&& randomInt < (accmulatedWeight + rule.getWeight())) {
				// select this rule
				return rule;
			} else {
				accmulatedWeight += rule.getWeight();
			}
		}
		return null;
	}

	/**
	 * determine iff this sentence need to be pop out of stack show check after
	 * qualified function
	 * 
	 * @return true iff this sentence not possible to make a qualified sentence
	 */
	public boolean needBackOffForSentenceOfLength(int sentenceLength) {
		if (this.sentence.size() > sentenceLength) {
			// when length of sentence is longer than given
			return true;
		} else if (this.rules.size() == 0) {
			// no remain rule to try
			return true;
		}
		return false;
	}

	public boolean qualified(int sentenceLength) {
		if (this.sentence.size() == sentenceLength) {
			// length of this sentence is qualified
			boolean allSymbolsAreTerminal = true;
			for (String symbols : this.sentence) {
				allSymbolsAreTerminal = allSymbolsAreTerminal
						&& this.cfl.getTerminalSymbols().contains(symbols);
			}
			return allSymbolsAreTerminal;
		} else {
			return false;
		}
	}
	
	public String getSentence
}
