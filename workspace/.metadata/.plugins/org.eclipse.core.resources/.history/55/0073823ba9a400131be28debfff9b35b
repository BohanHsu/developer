package sentenceBuilder;

import grammar.ContextFreeLanguage;
import grammar.Rule;

import java.util.ArrayList;
import java.util.LinkedList;

import utility.RandomNumberGenerator;

public class IntermediateSentence {
	private LinkedList<String> sentence = null;
	private LinkedList<Rule> rules = null;
	private ContextFreeLanguage cfl = null;

	/**
	 * constructor when this is a start symbol
	 * 
	 * @param cfl
	 *            : a context free language
	 * @param startSymbol
	 *            : a string of start symbol
	 */
	public IntermediateSentence(ContextFreeLanguage cfl, String startSymbol) {
		this.cfl = cfl;
		this.sentence = new LinkedList<String>();
		sentence.add(startSymbol);
		ArrayList<Rule> allRules = this.cfl.getMapping().get(startSymbol);
		this.rules = new LinkedList<>(allRules);
	}
	
	/**
	 * a successor constructor
	 * take a IntermediateSentence, this argument sentence must have rule remain to check,
	 * 
	 * @param is : a IntermediateSentence
	 */
	public IntermediateSentence(IntermediateSentence is) {
		// copy attributes from previous IS
		this.cfl = is.cfl;
		this.sentence = new LinkedList<String>(is.sentence);
		// randomly select a rule from previous IS
		Rule selectedRule = is.randomSelectRule();
		String fromSymbol = selectedRule.getFromSymbol();
		ArrayList<String> toSymbols = selectedRule.getToSymbols();
		// remove the selected rule from previous IS
		is.rules.remove(selectedRule);
		// modify sentence in this IS
		int index = this.sentence.indexOf(fromSymbol);
		this.sentence.remove(fromSymbol);
		this.sentence.addAll(index, toSymbols);
		// find first non terminal symbols in new sentence
		String firstNonTerminal = null;
		for (String symbol : this.sentence){
			if (isNonTerminal(symbol)){
				firstNonTerminal = symbol;
				break;
			}
		}
		
		if (firstNonTerminal == null){
			// this sentence only contain Terminal Symbols
		} else {
			// get rules from this symbol
			ArrayList<Rule> allRules = this.cfl.getMapping().get(firstNonTerminal);
			this.rules = new LinkedList<Rule>(allRules);
		}
	}
	
	/**
	 * given a string, determine iff this symbols is a non-terminal symbol
	 * @param symbol : a given symbols
	 * @return
	 */
	private boolean isNonTerminal(String symbol){
		return this.cfl.getNonTerminalSymbols().contains(symbol);
	}
	
	/**
	 * randomly select a rule form this structure, according to the rule's weight
	 * @return : a rule if possible, if no rules return null
	 */
	public Rule randomSelectRule() {
		int totalRuleWeight = 0;
		for (Rule rule : this.rules) {
			totalRuleWeight += rule.getWeight();
		}
		int randomInt = RandomNumberGenerator.randomIntTo(totalRuleWeight);
		int accmulatedWeight = 0;
		for (Rule rule : this.rules) {
			if (accmulatedWeight <= randomInt
					&& randomInt < (accmulatedWeight + rule.getWeight())) {
				// select this rule
				return rule;
			} else {
				accmulatedWeight += rule.getWeight();
			}
		}
		return null;
	}
}
