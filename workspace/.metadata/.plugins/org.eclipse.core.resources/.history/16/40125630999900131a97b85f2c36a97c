package graph;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map.Entry;

import comparator.EdgeWeightComparator;

public class Graph {
	private boolean isDirected = false;
	
	private HashSet<Integer> v = null;
	private ArrayList<Edge> e = null;
	private HashMap<Integer, Integer> root = new HashMap<Integer, Integer>();

//	HashMap<Integer, Double> dist = new HashMap<Integer, Double>();
//	HashMap<Integer, Integer> prev = new HashMap<Integer, Integer>();
	
	public Graph(String[] edge) {
		HashSet<Integer> ver = new HashSet<Integer>();
		this.v = new HashSet<Integer>();
		this.e = new ArrayList<Edge>();

		for (String string : edge) {
			String[] a = string.split(",");
			int src = Integer.parseInt(a[0]);
			int tgt = Integer.parseInt(a[1]);
			double weight = Double.parseDouble(a[2]);
			ver.add(src);
			ver.add(tgt);
			e.add(new Edge(src, tgt, weight));
		}

		this.v = ver;
	}

	public ArrayList<Edge> kruskal(){
		ArrayList<Edge> mst = new ArrayList<Edge>();
		ArrayList<Edge> sortedEdges = new ArrayList<Edge>(this.e);
		Collections.sort(sortedEdges, new EdgeWeightComparator());
		
		resetUnionFindRoot();

		for (Edge e : sortedEdges){
			int u = e.getSrc();
			int v = e.getTgt();
			if (find(u) != find(v)){
				mst.add(e);
				union(u, v);
			}
		}
		return mst;
	}
	
	/**
	 * union two vertex
	 * @param x : the id of first vertex
	 * @param y : the id of second vertex
	 */
	private void union(int x, int y){
		int xRoot = find(x);
		int yRoot = find(y);
		// the new root is from the tree specified by the first parameter to union.
		// y.parent <- x
		this.root.put(yRoot, xRoot);
	}
	
	/**
	 * find parent of a vertex
	 * @param x : id of the vertex need to find root
	 * @return : id of the root vertex
	 */
	private int find(int x){
		int xRoot = this.root.get(x);
		if (xRoot == x){
			return x;
		}else{
			return find(xRoot);
		}
	}
	
	/**
	 * reset the union find root of each vertex in the graph,
	 * set the root to the vertex itself
	 */
	private void resetUnionFindRoot(){
		this.root = new HashMap<Integer, Integer>();
		for (Integer id : this.v) {
			this.root.put(id, id);
		}
	}
	
	HashMap<Integer, Double> cost = null;
	
	/**
	 * delete the minimum value entry in the cost hash map
	 * @return the key of the minimum entry before remove
	 */
	private int deleteMin(){
		int index = 0;
		double min = Double.MAX_VALUE;
		for (Integer i : this.cost.keySet()) {
			if (this.cost.get(i) < min){
				index = i;
			}
		}
		
		this.cost.remove(index);
		return index;
	}
	
	public void jarnik(int source){
		ArrayList<Integer> = visited = new ArrayList<Integer>();
		
		// make queue
		this.cost = new HashMap<Integer, Double>();
		for (Integer vertex : this.v) {
			this.cost.put(vertex, null);
		}
		this.cost.put(source, (double) 0);
		
		// loop
		while (!this.cost.isEmpty()){
			int v = deleteMin();
			
		}
	}
	
}
