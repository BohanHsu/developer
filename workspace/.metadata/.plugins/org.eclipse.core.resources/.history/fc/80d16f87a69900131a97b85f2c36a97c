package graph;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map.Entry;

import comparator.EdgeWeightComparator;

public class Graph {
	private boolean isDirected = false;

	private HashSet<Integer> v = null;
	private ArrayList<Edge> e = null;
	private HashMap<Integer, Integer> root = new HashMap<Integer, Integer>();

	public Graph(String[] edge) {
		HashSet<Integer> ver = new HashSet<Integer>();
		this.v = new HashSet<Integer>();
		this.e = new ArrayList<Edge>();

		for (String string : edge) {
			String[] a = string.split(",");
			int src = Integer.parseInt(a[0]);
			int tgt = Integer.parseInt(a[1]);
			double weight = Double.parseDouble(a[2]);
			ver.add(src);
			ver.add(tgt);
			e.add(new Edge(src, tgt, weight));
		}

		this.v = ver;
	}

	public ArrayList<Edge> kruskal() {
		ArrayList<Edge> mst = new ArrayList<Edge>();
		ArrayList<Edge> sortedEdges = new ArrayList<Edge>(this.e);
		Collections.sort(sortedEdges, new EdgeWeightComparator());

		resetUnionFindRoot();

		for (Edge e : sortedEdges) {
			int u = e.getSrc();
			int v = e.getTgt();
			if (find(u) != find(v)) {
				mst.add(e);
				union(u, v);
			}
		}
		return mst;
	}

	/**
	 * union two vertex
	 * 
	 * @param x
	 *            : the id of first vertex
	 * @param y
	 *            : the id of second vertex
	 */
	private void union(int x, int y) {
		int xRoot = find(x);
		int yRoot = find(y);
		// the new root is from the tree specified by the first parameter to
		// union.
		// y.parent <- x
		this.root.put(yRoot, xRoot);
	}

	/**
	 * find parent of a vertex
	 * 
	 * @param x
	 *            : id of the vertex need to find root
	 * @return : id of the root vertex
	 */
	private int find(int x) {
		int xRoot = this.root.get(x);
		if (xRoot == x) {
			return x;
		} else {
			return find(xRoot);
		}
	}

	/**
	 * reset the union find root of each vertex in the graph, set the root to
	 * the vertex itself
	 */
	private void resetUnionFindRoot() {
		this.root = new HashMap<Integer, Integer>();
		for (Integer id : this.v) {
			this.root.put(id, id);
		}
	}

	HashMap<Integer, Double> pq = null;
	HashMap<Integer, Integer> prev = null;
	HashMap<Integer, Double> cost = null;

	/**
	 * delete the minimum value entry in the cost hash map
	 * 
	 * @return the key of the minimum entry before remove
	 */
	private int deleteMin() {
		int index = 0;
		Double min = null;
		for (Integer i : this.pq.keySet()) {
			if (operator.Operator.cmp(this.pq.get(i), min) < 0) {
				index = i;
				min = this.pq.get(i);
			}
		}

		this.pq.remove(index);
		return index;
	}

	public void jarnik(int source) {
		ArrayList<Integer> visited = new ArrayList<Integer>();

		ArrayList<Integer> vertexList = new ArrayList<>(this.v);
		Collections.sort(vertexList);

		// make queue
		this.pq = new HashMap<Integer, Double>();
		this.prev = new HashMap<Integer, Integer>();
		this.cost = new HashMap<Integer, Double>();
		for (Integer vertex : this.v) {
			this.pq.put(vertex, null);
			this.prev.put(vertex, null);
			this.cost.put(vertex, null);
		}
		this.pq.put(source, (double) 0);
		this.cost.put(source, (double) 0);

		// loop
		while (!this.pq.isEmpty()) {
			int v = deleteMin();
			// test
			System.out.println(v);
			// end
			visited.add(v);
//			// show set
//			System.out.println(visited);
//			// end

			// show vertices
			for (Integer integer : vertexList) {
				System.out.print(this.cost.get(integer));
				System.out.print("/" + this.prev.get(integer) + "\t");
			}
			// show set
			System.out.println(visited);
			// end

			System.out.println();
			// end

			for (Edge edge : edgeOfVertex(v)) {
				int z = 0;
				if (edge.getSrc() == v) {
					z = edge.getTgt();
				} else {
					z = edge.getSrc();
				}

				Double zCost = this.cost.get(z);
				Double w = edge.getWeight();
				if (operator.Operator.cmp(zCost, w) > 0) {

					this.cost.put(z, w);
					this.prev.put(z, v);
					// decrease-key
					this.pq.put(z, w);
				}
			}
		}

		// show set
		System.out.println(visited);
		// end
		// show vertices
		for (Integer integer : vertexList) {
			System.out.print(this.cost.get(integer));
			System.out.print("/" + this.prev.get(integer) + "\t");
		}
		System.out.println();
		// end
	}

	/**
	 * find all the edges in the graph include with one particular vertex
	 * 
	 * @param vertex
	 *            : the particular vertex
	 * @return a ArrayList contain all the edges contain those edges
	 */
	private ArrayList<Edge> edgeOfVertex(int vertex) {
		ArrayList<Edge> edges = new ArrayList<Edge>();
		for (Edge edge : this.e) {
			if (edge.getSrc() == vertex || edge.getTgt() == vertex) {
				edges.add(edge);
			}
		}
		return edges;
	}

}
